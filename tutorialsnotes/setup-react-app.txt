
REACT NATIVE AUTHENTICATION
THEORY:
gonna walk through the steps of creating an authentication context and provider
working with the API with a login and registration functionality and how to use the Expo Secure Storage
to manage JWT and store this in a secure place

PRACTICE:
CREATING AN AUTHENTICATION CONTEXT: 
1. Build a native app 
A. Start with the typescript template of Expo (we should just use typescript at this point)
B. Install a few packages: (SEE COMMENTS IN /start.sh)
C. Update /app.json, in the ios object, to include the following:
"config": {
    "usesNonExemptEncryption": false
}
2. With that in place uh we can run npx expo start
A. We can run this on the web, iOS, or Android; review the preview of the default app
3. Next, we want to create a login page and an inside page
A. And that inside page needs to be protected
B. So in order to protect that page and to have this logic we're gonna add context around our app
C. for our authentication and that context will be in a newly created folder, "/app/context"
D. Create a file AuthContext.tsx (SEE COMMENTS)
I. Once AuthContext.tsx is setup, you have done 99% of the work for building a JWT of your react native application
4. Now we just need to put this to work but that part is going to be pretty easy
SECURE YOUR REACT NATIVE APP
5.  We probably need some pages, so let's create a new folder, called /app/screens
6. Create a new file, /app/screens/Login.tsx and also /app/screens/Home.tsx
A. In VSCode, RNFS creates react native functional export, for a regnative functional export component
7. So those pages will be implemented in a second for now we just need like the dummy implementation
8. Now move over to App.tsx which is currently the entry point (SEE COMMENTS IN /app/App.tsx)
9. Restart Metro (?)
10. Save this (App.tsx)
BUILDING THE LOGIN
11. of course we don't really have a login screen so we should focus on that and quickly Implement that
A. (SEE COMMENTS IN /app/screens/Login.tsx)
B. Try to sign in (NOTE: you will probably get an alert message from the API, can't create user)
MAKING AUTHENTICATED API REQUESTS
12. SEE COMMENTS REGARDING testCall in /app/screens/Login.tsx and throughout /app/screens/Home.tsx 






TECH/TIM INSTRUCTIONS
1. Go to the base directory (goalsdrbackend at the highest level)
2. Use Vite to create a new react project: npm create vite@latest frontend -- --template react
a. This is going to create a frontend directory, which is going to have react installed
b. Navigate into this directory: cd frontend
c. We need to install the following packages: create-vite@5.5.2 Ok to proceed? (y) - respond y for yes
d. Select a framework: select React with arrow keys
e. Select a variant (I selected TypeScript - default)
f. Message from terminal: Done. Now run: cd goalsdrfrontend npm install npm run dev
3. Now we need to install a few different packages:
a. cd into goalsdrfrontend, and install:
b. npm install axios react-router-dom jwt-decode (axios for using our network requests)
4. Now, go inside frontend and start creating files
5. Go inside of src and start organizing this directory, and delete the css files (for tech/tim tutorial - leave for now)
6. The assets folder is fine, nothing to update
7. Go into frontend/src/App.jsx (or .tsx) and remove everything inside the body of the component (tech/tim - I will just comment it out)
a. Also remove (comment out) all import statements at the top, and replace with: import react from 'react';
b. Also remove (comment out) const [count, setCount] = useState(0) near the top
8. Now go into frontend/src/main.jsx (or .tsx)
a. remove (comment out) the import to index.css because we don't need that
9. Create a few directories in the folder structure to organize our code: frontend/src/ pages/, styles/, and components/
10. Create an environment variable file in frontend called frontend/.env and insert the line: VITE_URL_URL="http://localhost:8000" 
11. Then, under frontend/src/ create a file called constants.js and api.js
a. Create a file frontend/src/constants.js (SEE COMMENTS)
b. Create a file frontend/src/api.js, (SEE COMMENTS)
12. Create and open the file frontend/src/components/ProtectedRoute.jsx (SEE COMMENTS)



Navigation & Pages
1:09:00
jsx what else do we need and I'm going to do not found.
1:09:05
jsx okay now inside of each of these I'm just going to stub a component so I'm going to say const home let's zoom in a
1:09:13
bit okay or actually let's just make it function let say function home like that
1:09:19
and then we will export default home and from home we can
1:09:26
just return some div that says home
1:09:31
let's copy that and let's go into login and let's just change home here to be
1:09:39
login okay obviously we're going to fill in these components later but I just need to have some of them right now for my navigation for this one it'll be not
1:09:46
found so this is like a 404 page okay so we're going to do not
1:09:52
found and then not found and then lastly register this
1:09:59
is going to say register register
1:10:07
and register okay so now that we have our four pages let me make this bigger
1:10:14
so we can see it and close all of these what we're going to do is we're going to go to our
1:10:20
app.jsx and we're going to write the navigation essentially so how we go between the different pages using react
1:10:27
router Dom so let's start importing a few things we need again the idea is that this is the root of our application
1:10:33
and we want to be able to navigate between different pages by going to a different address in the URL bar so
1:10:39
that's what I'm going to show you how to implement so I'm going to say import the browser
1:10:45
router import Roots import roots and import navigation from react router Dom
1:10:54
I am then going to import the login component from this is going to be dot slash and this is going to be
1:11:02
Pages /login we are then going to import the register
1:11:08
component from do SL Pages SL register I'm then
1:11:15
going to import the home component from the same thing pages slome and we're
1:11:21
going to import the not found component from do/ Pages SL not found okay we also need
1:11:30
to import the protected rout so we're going to say import protected root from
1:11:36
SL components SL protected root okay now
1:11:42
we're going to write two very simple functions one for logging us out so I'm going to say function log out and all
1:11:50
log out is going to do is as soon as we call it it's going to say local storage. CLE so as as soon as we log out we're
1:11:56
going to clear our refresh token and our access token and we're just going to return a navigate so let's do this and
1:12:04
this is going to be two so let's write two equals slash
1:12:09
login okay and navigate we need to import that so do we have that imported
1:12:15
sorry this needs to be navigate not navigation okay so that is our log out function and then we're going to import
1:12:22
one more function or write one more function and this is going to be register and log out okay and what this
1:12:30
is going to do is it is going to say local storage. CLE then this is going to
1:12:36
return simply the register component now the reason why I'm writing this is that
1:12:41
if someone is registering I first want to clear the local storage so that I don't end up submitting access tokens to
1:12:47
the register route where I could potentially get an error so we just need to make sure that when we are
1:12:53
registering we first clear the local storage so we don't have any old access tokens lingering around I know it seems
1:12:59
a bit strange but it's just something that we need to do in order for this to work properly okay now what we want to
1:13:04
do is we want to set up this app component so we can navigate between our different pages so to do that we're
1:13:10
going to return the browser router okay this is a component from react router.
1:13:17
now inside of here we need to specify Roots so we're going to say roots and inside of here we can put all of our
1:13:22
different roots that we want to navigate between so let's begin by specifying the home root so we're going to say root
1:13:30
this is going to be a self-contained component and inside of here we're going to say the path is equal to this so just
1:13:35
the standard path if you go to just the normal path this is where it'll bring it to and the element that we want to
1:13:41
render here is going to be the following now this is going to be the protected roote and then inside of the protected
1:13:48
roote we are going to render home so the point is that you cannot access the home
1:13:54
component unless unless you have the access token and it's valid because you shouldn't be able to access that because
1:14:00
home is for people that are logged in and authenticated so that's how this works right we're wrapping the component
1:14:05
that we want to be protected with protected root and you can use protected root for any component that you want so
1:14:11
now we're going to do another rout and let's end it like this the path for this
1:14:17
one this time will be slash login and this element that we're going to render is going to be the login page
1:14:24
okay okay now that's not protected you can go to that no matter what now let's copy this and do the same thing for
1:14:31
register okay but the element we're going to go to this time is going to be the component we wrote so register and
1:14:37
log out right the one that's going to log us out first by removing the tokens
1:14:43
and then we're going to have another rout this is going to be path equal to and we're just going to put in asteris
1:14:49
and if you go to any other path we're going to render the element which is equal to
1:14:55
the not found Route which is going to be like a 404 page okay so what we're doing is we're looking first starting at the
1:15:01
very first route so we're saying okay is it the normal path if it is go to home if it's login go to login if it's
1:15:08
register go to register if it is anything else go to the 404 not found
1:15:13
page okay that's going to handle all of our routing now we can actually test if this routing is working so to do that
1:15:20
we're going to bring up our code here notice we're inside of the front end directory and we're going to type npm
1:15:27
and actually I believe we are going to need to install uh okay no actually that seem to work that's fine and then we're going to
1:15:33
type npm run Dev now when we type npm run Dev that's going to run the development server for us what we can do
1:15:40
now is we can open it up let me just bring it over to the other page and you'll see that we go to login by
1:15:47
default if I try to go to home notice it's redirecting me to login because it is a protected route and we don't have
1:15:53
our access token now let's see what happens if we go to register brings us to register and if we
1:15:59
go to something like some random string it brings us to not found okay so that's
1:16:05
working so let's go ahead and shut this down and start writing some more of our components okay so first component that
1:16:11
I think is pretty easy to get out of the way is the 404 or the not found component so let's write that one so for
1:16:17
this all we can do in here is just remove that and we can go with an H1 tag
1:16:23
and we could say 404 not found and then we can go with ap and we can say the
1:16:29
page you're looking for does not exist okay like that that's
404 Page
1:16:40
fine and maybe we'll do doesn't exist okay so that's good for the not found
1:16:46
page next what I actually want to write is I want to write a generic form that can be used by our register and by our
1:16:54
login page and I also realized here that we didn't implement the logout route so let's quickly do that so we're just
1:17:00
going to write another one here and just change this to say log out and we'll go
1:17:05
to log out okay so sorry just add that one I just forgot that right there okay so as
1:17:10
I was saying what I want to do is I want to make a form this form will just collect a username or password and then
1:17:16
submit it to either the register route or to the login route now we can just
1:17:22
write one form and we can just kind of make it a bit dynamic so it works for both registering and logging in because
1:17:28
for our registration it's the exact same process as logging in right just a username and password it'll be the same
Making A Generic Form
1:17:33
for both so what I'm going to do is go to components and I'm going to make a form. jsx so inside here let's import a
1:17:40
few things that we need we're going to say import use state from react we're going to say
1:17:49
import API from do/ API I'm going to say import
1:17:56
and this is going to be use navigate from react router Dom okay this a hook that we can use to actually access the
1:18:02
navigation from code I then am going to import the access token okay come on
1:18:08
give it to me and the refresh token from our constants and I am going to actually
1:18:15
for now that's it okay we're now going to write a function this is a form and
1:18:21
we're going to take in two props the props that we're going to take in our root and our
1:18:27
method okay now the root is the rout that we want to go to when we submit the form so it could be the token route or
1:18:33
it could be the register route and the method is just telling us okay are we registering or are we logging in the
1:18:39
idea is this form will work again for both logging in and registering and this is the dynamic props that we'll pass to
1:18:44
specify what it should be used for so in terms of the state we're going to need to store the username and the password
1:18:50
that the user is typing in so we're going to say con username uh what is it comma set username is equal to use State
1:18:58
and this will be an empty string we're then going to say const password and then set password is
1:19:06
equal to use State and this will be an empty string and then we'll do one more piece of state to just keep track of if
1:19:12
we're loading or not so we're going to say con loading set loading is equal to
1:19:18
use State and this will be false to start we're then going to say const
1:19:24
navigate is equal to use navigate and we'll call that hook okay now what we
1:19:31
want to do is just write a basic form so we're going to say return and we're going to return a form now the form is
1:19:38
going to have on submit okay and this is going to call a function and the function it's going to
1:19:44
call is handle submit so we can stub that function right now we can say cost
1:19:49
handle submit is equal to a function and instead of here we're going to take in E
1:19:55
and we're going to say e. prevent default now what this will do is prevent
1:20:00
us from actually submitting the form and it will kind of remove the default Behavior so we won't reload the page
1:20:06
because we don't want to reload the page here when we're doing that okay so now that we've made the form I'm just going to add a class to this because we're
1:20:11
going to style it in a second so I'm going to say class name is the form container and then inside the form
1:20:18
we'll write our different elements so first things first we're going to write an H1 tag and we're actually going to
1:20:24
look at what the method is that's passed as the prop now we're going to say if the method is equal to login then we're
1:20:30
just going to uh render login as the text inside of here otherwise we're going to Lo uh render register sorry
1:20:37
okay so this is just giving us the name and in fact what we can do just to make this a little bit cleaner is we can say const name is equal to and we can copy
1:20:45
this and paste this here and then we can just render the name inside of here so
1:20:50
the idea is we're just getting the name that we should put for the title of the form okay so if it's login then do login
1:20:57
otherwise do register so method will be either equal to login or register okay now we're going to have some input
1:21:03
fields for the username and the password so we're going to say input okay and for the first input we'll specify the class
1:21:11
name equal to and this can be the form D input then we can do type is equal to
1:21:18
text we can do the value is equal to username and on change
1:21:25
is equal to and then we're going to take in a function here and this is going to be e and then set username so let's
1:21:32
spell that correctly and this is going to be e. Target doval okay lastly we'll have a
1:21:40
placeholder and this will be equal to username okay so this is one of our input Fields again form input type text
1:21:48
value username so this means that anytime we make a change here we take in the variable e we're then saying set us
1:21:54
us name and then whatever we typed we're just going to adjust and set that in the state so that we'll be able to access
1:21:59
that when we actually submit the form now we're going to copy this and we'll just do similar thing here for the password so we're going to change this
1:22:06
from type text to type password we're going to change the value to be password
1:22:13
we're going to change set username to be set password and we're going to change the placeholder to be
1:22:19
password okay almost done last thing we want to do now is add the button cuz we need a button to submit so for the class
1:22:26
name of this button it will just be the form-b button and the type of this will
1:22:31
be submit and then inside of the button we're just going to put the name that we
1:22:38
have from up here so it'll either say login or register depending on the method that we pass to this form okay we
1:22:44
can zoom out a little bit so it's a bit easier to read and that's it for the actual uh jsx or uh what do you call it
1:22:51
word rendering on the screen let me just format this and now let's write our
1:22:56
handle submit method so when we submit the form the first thing we'll do is
1:23:01
we'll set loading equal to True okay let's zoom in so we can see this a bit
1:23:08
and then after that we're going to attempt to send a request to whatever root it is that this form is
1:23:14
representing so we're either going to try to log in or we're going to try to register so what we'll do is we'll set
1:23:19
up a TR catch because this could fail okay and we're going to make this
1:23:24
an Asing function as well okay so we're going to catch error if we have an error
1:23:30
we're just going to alert what the error is so it'll just show it on screen and then we're going to add a finally block
1:23:37
and we're going to say set loading false so no matter what happens
1:23:43
we're going to try to send the request if there's an error we'll catch it and whether it worked or it didn't work we're just going to set loading equal to
1:23:49
false because eventually we'll have a loading indicator here and we want to obviously like turn that off right and
1:23:54
let me just fix this a little bit okay so inside of our try we're going to send
1:23:59
a request so to send the request we're going to say const res is equal to await
1:24:05
api. poost and we're going to post to the root that was passed into the form
1:24:12
we then are going to pass a username and a password so this is it
1:24:17
it's going to use the API that we wrote it's going to send a post request to whatever the route is pass the username
1:24:23
and password we're going to wait until we get that back and we're going to check the following we're going to say
1:24:28
if method is equal to login then what we're going to do is say
1:24:35
local storage. set item and we're going to set the access token to the res. dat.
1:24:42
access and we're going to say local storage do set item and we're going to set the refresh token to be res.
1:24:51
dat. refresh okay so the idea is we're going to send
1:24:56
this request if an error occurs it'll be handled here in the catch if there's no error that occurs then we're going to
1:25:02
check if the method was log in if it was that means that we need to get the access token and the refresh token and
1:25:08
we need to set them okay then we are going to navigate to the slash login or sorry not
1:25:17
to the SL login to the SL page so we're going to use the navigate function that we have here and just navigate to home
1:25:22
so we'll be able to view our notes which you'll see in a second otherwise we are going to
1:25:28
navigate to/ login the reason for this is that if it wasn't login it must have
1:25:34
been register if it was register there's no tokens that we need to set in order to get the tokens we actually need to
1:25:40
log in with our new registered account okay so that's our form again we can
1:25:45
kind of zoom out a little bit so you can read it a little bit better now there's some more things that we'll do here later on but for now I just want to
1:25:52
apply The Styling and then I want to actually go to these elements and test out and see if they're working so for
1:25:57
the styling I'm going to make a new style sheet here in Styles and I'm going to call this
1:26:02
form. CSS now what I'm going to do is just copy in the Styles I'm not going to write them out because I think that's
1:26:09
kind of a waste of time so I'm going to paste in all of the Styles here if you want these Styles you can simply have
Adding Form Styles
1:26:15
them from the GitHub repository that is linked in the description okay so you can just go find them from the for. CSS
1:26:21
file and just paste them in your own file or you can just cop the entire file right whatever you want to do anyways I've read them in here in order for
1:26:28
these styles to be applied though we do need to import that file so we're going to say import do do
1:26:34
Styles form. CSS okay just so that we'll have some nice styling last thing we
1:26:40
need to do is we need to export this component so we're going to say export default form and now that we have
1:26:47
exported the form we can start using it so now that we have the form component we're going to use that from the login
1:26:53
and from the register component component and it's going to be pretty straightforward but all we'll do from login here is we'll start by importing
1:27:00
the form so we're going to say import form from dot slash or dot dot slash if
Connecting The Login/Register Form
1:27:07
we can do two dots components SL form and then rather than returning this div
1:27:14
we're just going to return the form component but we're going to pass two props to it now when we're logging in or
1:27:20
sorry when we're registering the route that we want to go to is API slash
1:27:25
userregister again make sure you have that trailing slash then the method is
1:27:31
going to be equal to register okay so that's it that's all we
1:27:37
need to do we're just setting the rout that we want to send the request to and we're specifying the name or the method which is register now we can copy this
1:27:44
same thing and we can go to login and for login we need to import the form again so we're going to say import let's
1:27:51
zoom in uh form from do do/ components SL form this time for
1:27:58
login the root is going to be API SL token slash and the method is going to
1:28:04
be to log in okay so now we should be using this for both the login and the
1:28:11
register route and we can check if we are by clearing and going to npm runev
1:28:17
so now if we open this up let me just bring this over so we can see it because it keeps opening on my other screen you
1:28:23
see that we have a login field and if I go to slash register we have the register form now
1:28:31
the main thing to check here is if the token is actually going to be working however before we can do that we need to
1:28:37
make sure that the back end is running so what I want to do now is I want to split my terminal here I want to CD into
1:28:45
the backend directory and I want to run my app so I'm going to say python manage.py run server all you need to do
1:28:52
here is get in the backend directory and just run the server like you normally would okay so we're going to run this now and let's just check where it's
1:28:58
running right so HTP 1.7.0 point0 point1 Co in 8000 I'm going to copy that and
1:29:05
I'm going to go to my environment variable and I'm just going to paste it inside of here just so it's exactly what
1:29:11
we had before and actually I think I got to remove that trailing slash otherwise
1:29:16
we might get an error okay I'm just going to shut down my V server and I'm just going to rerun it to make sure it
1:29:21
reloads the environment variable and now I have my back end running and my front end and technically we should be sending
1:29:27
requests now to the back end so let's test that out so what I'm going to do from register is I'm going to say
1:29:33
newcore user and let's go with a password like 1 2 3 4 5 and I'm just
1:29:38
going to open up the inspect window here in my console so I can see what's happening so let's click on register and
1:29:45
notice that it redirected me to log in now if we want to see if that's working we can go to our back end and we'll see
1:29:50
that a post request was actually sent here and even shows us what the options were username new user password here I
1:29:56
don't know if maybe I printed that out or something I'm not sure if that's supposed to show us regardless you can
1:30:01
see the post was successful with 2011 it immediately redirected us to login so now I can try to log in so I'm going to
1:30:08
go new user then 1 2 3 45 log in and notice it brings me to home so I can
1:30:14
access home even though it's a protected route because now I have my access token and if we go back here and we look uh
1:30:21
where is it we have a post to token and you can see we have a status code of 200 working successfully okay so we're able
1:30:27
to communicate no cores errors everything is good and let's see what happens uh actually I guess there's not
1:30:33
much more that I can check I mean I can go to login okay it brings me there and I can go back to home because I still
1:30:39
have the access token but you'll notice now if I go to SL logout it's going to
1:30:44
redirect me to login and if I try to go back to home it doesn't let me go there because I'm no longer authorized because
1:30:51
I've logged out so I would need to log in again newcore user okay and then it will bring me to
1:30:58
home and I'm good to go all right so there you go we're making really really good progress now now that we've done
1:31:04
that we want to start writing the homepage so we can actually start making some notes and our application can actually do something so we're able to
1:31:10
log in we're able to register the form is built I would say the hard part is done and now we need to start actually
1:31:17
interacting with our notes so that's going to involve writing some code inside of the homepage here so let's
1:31:23
start doing that so from our homepage what we want to be able to do here is view all of the notes that we have and
1:31:29
then create new notes and delete notes so let's go through those operations one at a time we're going to start by
1:31:36
importing a few things so I'm going to say import and we're going to import use
1:31:41
State and use effect from react okay and we're going to import our
Building The Home Page
1:31:49
API from dot do/ API
1:31:55
okay now inside of home let's start with the state that we need so we're going to need to keep track of all of the notes
1:32:01
that we have that we've already grabbed from the server because the first thing we'll do when we load this page is we'll
1:32:06
send an authorized request to get all of the notes that we've created so let's do that first we're going to say con notes
1:32:14
set notes is equal to use State and this will be an empty array we then need some State for the
1:32:22
form that will be on this page that allows us to create a new note now I'm going to do it all in this component we
1:32:27
could put it in a separate component if we wanted it to be cleaner but in this case I'm just going to have some State for the content and for the title of my
1:32:35
note so I'm going to say con content set content is equal to use State this will
1:32:43
be an empty string I'm then going to say const and this is going to be title
1:32:48
set title is equal to use State and this
1:32:55
is going to be an empty string and now what we're going to do is write a few different functions that will send some
1:33:01
requests so I am going to write all of the HTML obviously in a second but I want to show you how we send the request
1:33:07
to for example get all of the notes that this user has written so we're going to write a function called get notes now
1:33:14
this can be written like this and what this is going to do is say API doget and
1:33:20
we're just going to call the/ Api SL notes root notice I have my trailing
1:33:26
slash okay now if you weren't sure how you would figure out what this route is in the back end remember if we go to API
1:33:34
and URLs we have these different roots that we've written right we have the notes rout and we have notes / delete
1:33:40
now the reason I'm prefixing this with API is because the way that we forwarded the URLs if we go back into back end
1:33:47
here is anything that had API and wasn't one of these roots up here got forwarded
1:33:52
to the other API roots that we have here so that's why I know that that's the correct route hopefully that's helpful
1:33:59
but the idea is we've ridden all of these paths in our back end and now we're going to access them from our front end okay so I have api. getet SL
1:34:07
API notes slash that's going to give me all the notes this user has written so I'm going to have a then and I'm going
1:34:14
to say res and I'm going to return my res. data I'm then going to have another
1:34:19
dot then and inside of here I'm going to have my data and I'm going to say set
1:34:28
notes equal to whatever the data is now let me just format this so it looks a
1:34:34
little bit nicer okay then we're going to have a catch in case there's an error and if there is an error we're just
1:34:40
going to alert the error on screen okay and let me format this so that we get it
1:34:46
looking nicer okay so there we go that's our get note function that will get all of the notes for us and really this should be get notes so what we can do is
1:34:54
we can write a use effect and this use effect can simply
1:35:00
call the get note function sorry as soon as we visit this page and then what we
1:35:06
can do is inside of the then we can just console.log what the notes
1:35:11
are so console.log and this will be the data
1:35:16
just so that we can see what it is uh when we load this component okay so before we go much further let's actually
1:35:23
just see if this request works so let's open up our terminal here let's go back
1:35:28
to our front end and let's refresh and notice that you see we get an empty list here okay so we're getting the empty
1:35:34
list the reason why we're getting the empty list is because well there's no notes that we've created and if we go
1:35:39
back here you can see that it's sending the request to SL API sln notes perfect
1:35:45
okay so let's bring that down and then let's continue writing our code so now that we have get notes let's have a way
1:35:52
to delete notes notes and to create notes now to delete a note we're going to say
1:35:59
const delete note and we need to take in the ID of the note that we want to
1:36:05
delete then what we'll do is we'll say api. delete because the request is
1:36:10
delete this time we're going to use some back Texs and we're going to say SL API sln notes SL delete slash and we're
1:36:18
going to pass inside of here the ID of the note that we want to remove
1:36:24
we're then going to say do then and we're going to get the response and we're going to check the status code of
1:36:30
the response so we're going to say if res. status is equal to 204 which means
1:36:37
we successfully deleted it then we're going to have an alert and we'll say note was deleted okay otherwise we're
1:36:46
going to say alert and then failed if we do this failed to delete
1:36:53
note like that okay then we're going to have a catch and for the catch we're
1:37:00
going to catch an error and we're going to alert whatever that error is on screen and then I'm just going to call
1:37:06
the get notes function this is not the most optimal way to do this but the idea is if we just deleted a note then it
1:37:12
means that our notes have changed so I want to show that update on the screen so we'll just call get notes again and
1:37:17
then that will actually update the screen by removing the notes when we receive the new notes from our backend
1:37:24
really what we should be doing is on the front end just removing it from this list but I don't want to write that JavaScript to do the removal so we're
1:37:30
just going to do it like this okay so I'm just going to format this again so it's a little bit easier to read and now
1:37:36
we need to write our last function before we get into the HTML which is creating our notes so to create our
1:37:42
notes we're going to say const create note and we're going to take in some value e because this is going to come
1:37:48
from a form and we're going to say e do prevent and then default
1:37:54
okay we're then going to say api. poost and we're going to post to SL API SL
1:38:00
notes okay so the same one that we use to get our results but this time we're not using get we're using post and what
1:38:06
we'll do is we'll pass the content and the title of the note we want to create
1:38:12
then similarly to before we're going to take in the response here in the do then and we're going to say if the response.
1:38:20
status is equal to 200 or sorry to 20 one which means we created the note
1:38:25
we're going to say alert and then note if we can do this created okay otherwise there was an
1:38:34
error so we're going to say alert and then failed to make
1:38:41
note okay then we need a do catch same thing if we have an error so we'll say
1:38:47
error like this then we are going to alert the error and then lastly we're
1:38:53
going to do the same thing we're going to say get notes like that okay and
1:38:59
let's Zoom back in and format and now we have our create note function okay so we
1:39:07
have create note delete note and get notes now we need to write the HTML okay
1:39:12
so for our HTML we kind of have two main components here the first part is just displaying all of our notes and the
1:39:19
second part is going to be a bit of a form to create a note so for displaying our not notes we'll just make a div here
1:39:25
and we're going to say H2 and then notes then inside of here we're actually going
1:39:30
to render all of our notes however I'm going to write a separate component that will display the notes so for right now
1:39:35
we're just going to leave that empty we're now going to come down here though and we're going to make a form and this form is create a
1:39:42
note okay so we're going to write a form and this needs to be in lowercase the
1:39:49
form is going to have an onsubmit and the onsubmit is going to be equal to the create note function now inside of the
1:39:55
form we're going to write our different elements so we're going to have a label
1:40:01
this is going to be HTML 4 equal to the title and this is going to say title
1:40:08
colon where then going to have a Brak line and we're going to have an input
1:40:14
field for the input we're going to say type is equal to text we're going to say
1:40:19
the ID is equal to the title we're going to say the the name is equal to the
1:40:25
title and we're going to say required and then onchange is going to be equal
1:40:31
to and this is going to be e and then set like this set title and then
1:40:40
e. target. Val don't worry I'm going to save it so we can actually see what it
1:40:45
looks like okay so this is the input type equals text ID title name title on
1:40:51
change we'll also set the value equal to the title perfect okay so that's the first
1:40:58
part now we need the same thing but for the content so I'm just going to copy this and paste this down here and change
1:41:05
this to say content and then this will say content and then we're going to use a text area
1:41:12
this time so it's a little bit larger so we're going to say text area and inside of text area we're going to say
1:41:18
ID is equal to content we're going to say name is equal to content we're going
1:41:24
to say required we're going to say value is equal to content and we're going to
1:41:30
say onchange is equal to and then this is going to be a function where we take
1:41:36
in E let's save this or actually it's it's just going to work right now okay
1:41:41
let's go there so it's going to be function e and then this is going to be set content e.
1:41:48
target. value okay I no this a lot we're almost done we're now going to have
1:41:54
another brake line and then beneath this we're going to have an input and this is going to be type equal
1:42:00
to submit and we'll say the value is equal to
1:42:06
submit okay and let's format it nice okay zoom out a bit so we can read it a
1:42:12
bit easier you can see that what we're returning here is a big div inside the div we have a first part which will
1:42:18
display all of our notes in and then we have a second part here where we are going to create a note when we submit
1:42:24
the form it's going to call the create note function which is going to pass the title as well as the
1:42:31
content okay uh oh last thing yeah value content okay so that's good all right so
1:42:37
I think that's going to complete the homepage other than displaying all of the notes so let's test this out let's make sure our servers are currently
1:42:44
running looks like they are we'll come back here and you can see that we have kind of a sketchy little uh form here
1:42:49
we'll fix that in a second but for now let's see if we can make a new note so we're going to say test note and then
1:42:55
test content and submit and it says the note was created and if I refresh here
1:43:02
you can see now that we have a new note okay so it says author is id2 content
1:43:08
test content created at ID title perfect that is working okay now we did have an
1:43:14
issue though where when I created the note it didn't update right away so I just want to see why that was the case I
1:43:21
think it's because we need to put the get note notes inside of the then yes
1:43:26
that's going to make sense so we'll put that inside of then and we're going to do that for all of the places where we created it so we're going to take
1:43:33
this and put it here okay perfect so that should fix that for us and now we
1:43:40
want to start displaying the different notes and we also want to style this page a bit we'll do the styling after first we're going to make a new
1:43:46
component inside of the components directory called note. jsx okay this is going to represent one
1:43:54
single note and we'll just use this to render all of our notes really easily so we're going to say
1:44:01
import react from react we're then going to make a
1:44:08
function called note now the note is just going to take in the note itself and a function which is on
Building The Note Component
1:44:14
delete and we're going to return um some jsx here or some HTML so we're going to
1:44:20
have a div the class name of this is going to be the note
1:44:26
container okay we're then going to have a P tag this is going to have a class name equal to the note title this is
1:44:35
going to be note. tile we're going to have another P tag
1:44:42
this is going to say class name is equal to and this is going to be the note and
1:44:47
content and then you guessed it this is going to be the note do content we're
1:44:53
then going to have another P tag and this is going to be class name equal to
1:44:58
the note date and then what we're going to do is pass in a value here which I'll put in in a second and then we're going
1:45:04
to have a button and this button is going to have a class name equal to
1:45:10
delete button and it's going to have an onclick equal to and we're going to call
1:45:19
the on delete function so we're going to have a function that calls on delete delete and passes the note. ID and then
1:45:26
here this will say delete okay let's format this so we can read it nice so
1:45:35
what we're doing right is we're rendering the container inside of here we're going to have the title the content we're going to put the date here
1:45:41
which I'm going to do in a second and then we have the delete button which will call the on delete function that we
1:45:46
pass as a prop with the ID of the note which is what we'll need to actually delete the note so that's why we wrap
1:45:52
this with another function so we can pass this uh argument here into the function so now I'm just going to make a
1:45:58
variable I'm going to say const formatted date is equal to new date and
1:46:03
I'm going to take in the note. created at and I'm just going to convert this to a local date string in
1:46:12
enus now what this is going to do is just strip off all the parts that we don't need to see like the time zone and
1:46:18
it's just going to tell us what the date was when we actually created this string so it's just going to give us a nicely
1:46:24
formatted date essentially I know I said that kind of backwards it's just going to make the date look nicer that's all it's doing now you can do all kinds of
1:46:30
formatting for it but that's fine for now so we're going to pass the formatted date here where we were kind of missing
1:46:36
that value now that we have this note component we can use it inside of the
1:46:41
home page so to do that where we have notes here we're going to start rendering all of our note components so
1:46:48
to render our note components we're going to render some code here and we're going to say notes
1:46:53
map and we're going to map each one of our notes and we're going to show the
1:46:58
note component so we're going to say note the note is going to be equal to the note on delete is going to be equal
1:47:07
to and then this is going to be the delete note function so it will call that with the ID we're then going to say
1:47:13
the key is equal to the note. ID just so we don't get that error that we so commonly see where it says hey we need a
1:47:19
key on all of our dynamically rendered elements so let's format this again and
1:47:26
there we go okay so we're rendering notes however we need to import note so let's do that from the top of our
1:47:31
program we can say import notes from dot do/
1:47:39
component slote okay we're almost done here so
1:47:45
let's bring this up and let's test this now so we're going to come here and refresh and it gives an an error here
1:47:51
sorry it says Source comp components note. jsx does not provide exported named default okay let's fix that error
1:47:58
so we're going to go back to note and we need to export this so we're going to say export default notes all right so
1:48:05
let's go back to our front end and we can see now that the note is appearing if I refresh it works and I can delete
1:48:12
it and notice it goes away now let's add a little bit of styling here and then that's going to pretty much wrap up the
1:48:17
front end and then we can move on to the deployment okay so let's begin by styling the note to do that we'll just
1:48:23
go to Styles we'll make a new one called note. CSS and while while while we are
1:48:29
here excuse me I will do home. CSS and we're going to add a component called loading indicator so I'm just going to
1:48:36
add that while we're here okay I'm going to go to note. CSS I'm just going to copy in all of the code again you can
Frontend Finishing Touches
1:48:42
find this from the GitHub repository I don't like just writing a bunch of CSS in a video I find it's not very useful
1:48:49
okay so that's for note for home let's copy in this okay again all this
1:48:57
available from the GitHub and then loading indicator let me copy in this code paste it and format it okay so that
1:49:08
is that for the Styles now we need to import it so from home. jsx we're going to import our Styles so we're going to
1:49:15
import do/ stylehome docss now let's go to the same thing for
1:49:22
our what is this note okay and we'll import note. CSS
1:49:30
okay let's go back here now and you can see that looks quite a bit nicer and now we can do
1:49:35
hey what is up submit that note created and you see the note pops up we have our
1:49:41
date delete button Etc okay last thing to do is add a loading indicator so for
1:49:47
example if we go to slash log out in the logi when I press login I want to see a
1:49:54
login kind of loading indicator when we are loading so to do that we're going to make a new component so inside of
1:50:00
components we're going to say loading indicator like that do jsx we've already
1:50:07
got the CSS written for it but now we're just going to write the component which is very straightforward so we're going to say import do do/ Styles SL loading
1:50:18
indicator if we can type this indic indicator. CSS okay we're then going to
1:50:25
say const loading indicator and this is going to be actually we make this as an
1:50:32
arrow function okay then we're just going to return here a div for the div
1:50:40
we're going to say class name is equal to loading container and
1:50:46
then we're going to have a div and this is going to be class name is equal to loader and then we're just going to
1:50:53
export default the loading indicator okay now
1:50:59
we can use this anywhere that we want so we're going to go to our form and let me just make this a bit smaller inside of
1:51:05
our form in between the last input and the button we're just going to write some conditional rendering here so we're
1:51:11
going to say loading and and and then the loading indicator like that and we
1:51:17
just need to make sure we import the loading indicator from the loading indic indicator component sorry so pretty straightforward
1:51:23
we're just going to show the loading indicator when we're loading and then the CSS that I wrote um inside of the
1:51:28
loading indicator file here will automatically do like the nice animation for us so if we go back here now you
1:51:35
should see it kind of pops up here right while we're waiting for this Okay click okay and there you go the loading indicator component has now been written
1:51:42
so with that said guys that is going to wrap up the front end at this point now we have the front and finished we have
1:51:47
the backend finished everything is working on Local Host The Next Step here is going to be to deploy a database
1:51:53
connect to the database and then we're going to deploy both the back end and the front end using coreo so let's go
1:51:59
ahead and do that starting with our database all right so now that the front end and the back end are finished we're
1:52:04
going to be deploying our database now as a reminder we're going to be using Coro to do that this is completely free
1:52:10
they're also the ones that are running that challenge for the Cyber truck or the $100,000 so really follow along with
1:52:17
these steps here if you want to make sure that you're eligible to enter that so what we're going to have to do here is go to the Coro website I'm leave a
Database Deployment
1:52:22
link to it in the description once you're here you got to create a new account or log into an existing one I'm
1:52:28
going to do that please do that and then we'll be brought to a portal and I'll kind of show you how we create the database all right so once you sign into
1:52:36
your Coro account you will be brought to the dashboard now from here you can do a lot of stuff and you can actually create
1:52:42
a project but the first thing we want to do is just create the database integration after that we're going to
1:52:48
make a project within that project we're going to create some components we're going to have our back end and our front
1:52:54
end and we're going to use Coro to actually link these two together this is a really cool platform it's actually
1:52:59
really fast to be able to spin up and deploy different applications best part is it's free when you're in the
1:53:04
developer tier and obviously you can upgrade if you wanted to do more production ready deployments okay so
1:53:09
what we're going to do is go to the dependencies tab on the left hand side of the screen and we're going to click
1:53:14
on databases now it's going to bring us to this page right here and what we can do is we can create a new database now
1:53:21
I'm just going to delete the one that I already have because I can only have one going at a time and this is going to act
1:53:27
as a trial database uh it's not really meant to be production ready but it's just allowing you to mess with the
1:53:32
features and try it out so it's a good thing to get some practice on how we actually deploy regular databases and
1:53:38
how we connect to them from D Jango so what I'm going to do is create a new database I'm going to select post Christ
1:53:44
SQL and for the name I'm just going to call this database you can call it whatever you want but make sure you select postris okay now you're only
1:53:52
going to have one option here for the hosting the reason for that is because this is kind of like a free trial demo
1:53:58
database under the developer tier so you can see you can try it out for free for seven days and then you'd have to
1:54:04
recreate it if you wanted to keep using it so I'm going to go United States digital ocean and hobbyist plan here it
1:54:10
says 3 cents per hour but don't worry you don't have to pay for it it is free and then it's going to create this service now it'll take a few minutes to
1:54:17
spin up the database and one thing to know is that this is a trial database so it's going to be powered off every every
1:54:22
hour so what that would mean is if it if it is powered off sory you got to come back here and just power it on manually
1:54:28
but for development purposes this is totally fine so while this spins up what we're going to do is copy all of the
1:54:35
values that we have here into an environment variable file in our uh what do you call this backend kind of python
1:54:43
script or backend python project so let's set that up while this is creating so I'm going to go back here and I'm
1:54:49
just going to close all of this and we're going to open up our backend directory and we're going to go to just
1:54:55
the main kind of root directory here and we're going to create an EnV file so we're going to say dot EnV for the EnV
1:55:03
file we're going to specify a few variables and then we're going to use the values from this page here as those
1:55:08
values so the first variable we need is going to be our dbor host we're then
1:55:13
going to have our dbor Port okay we're then going to have our dbor user and our
1:55:20
dbor name and our password dbor
1:55:25
PWD okay so now we're just going to take all the values from here and we're going to copy them into the corresponding
1:55:31
variables so let's copy the host to start we're going to put a set of quotes and paste that in here for the port this
1:55:39
is going to be 21510 so let's paste that over here for
1:55:45
the user it's going to be this let's make sure we put that inside of quotes here and for the name it's going to be
1:55:52
default DB and then we'll need to wait for the service to be created before we have
1:55:58
access to the password and actually I'm just going to surround this in quotes because that's what I have in my demo
1:56:03
project so I don't want to mess anything up okay so let's wait for this to finish it's going to give us the password we can click to view it and then we'll put
1:56:10
it in the environment variable file and we'll be good to move on to the next steps all right so the service has been
1:56:15
created here and I just copied the password and put it in my environment variable file now that we've created the
1:56:21
database what we want to do is connect to it from D Jango and then we can provision it using pythons manage.py or
1:56:28
what exists here inside of D Jango and then we can just use our application like we normally would except this time
1:56:33
will'll be connected to a remote database so in order to do that we need to go into backend settings.py and we're
1:56:39
going to go to the databases so where it says databases here what we're going to do is change a bunch of these things so
1:56:47
where it says engine we're going to change the engine to be Jango in low lower case. DB doback ends.
1:56:57
postgis SQL like that then for the name this is going to be the environment
1:57:03
variable which is os. getet EnV and we're going to get the DB name
1:57:09
now the reason why this works is because at the very top of our code we load in our environment variable file and we
1:57:16
have all those variables in the EnV file so make sure they're there for this to work okay so now that we have the name
1:57:23
the next thing that we need is the user so we're going to say the user is equal to os.
1:57:29
getv and this is going to be the dbor user we then need the password the
1:57:37
password is going to be os. getet EnV and this is going to be
1:57:43
the dbor PWD for password we then are going to have the host and the host is
1:57:50
going to be os. get EnV and this is going to be the host or the dbor host I
1:57:56
should say and then lastly we need the port and the port is going to be os.
1:58:01
getet en EnV and then dvore Port okay and let's make sure we have our commas
1:58:07
so that's it that will configure our database so now that we have all of our environment variables loaded in we can
1:58:13
actually connect to the database what we need to do now is let's bring up our terminal I'm going to stop running the
1:58:19
back end here so let's stop that and for some reason I think we were getting an error where it was saying
1:58:25
that this was typed wrong it was okay so I just spelled that incorrectly so let me fix that quickly and now what we're
1:58:31
going to do is type Python manage.py and then migrate what this is going to
1:58:38
do is connect to that remote database you're going to notice this will take quite a bit longer because we actually need to connect over the Internet we're
1:58:44
not connecting locally so once this is finished I'll be right back okay so this code just finished running so now what
1:58:50
we can do is type python manage.py and then run server and now our server will
1:58:56
be running just like before and what we can do is we can go back here and we can start using our app as we normally would
1:59:03
so now we're going to be in a new database so we'll need to make any accounts again so I'll make an account
1:59:09
set the password okay you're going to notice it will take longer now because again we're connecting to that remote
1:59:15
database not the local one so let's try to sign into our account okay log in
1:59:23
let's wait and it should bring us to the homepage there you go we have the homepage and we could go and we could
1:59:28
make our notes so now we're just connected to the remote database if we want to see the logs we can go and view it we can see metrics advanced settings
1:59:35
all kinds of stuff here uh very useful and also super super easy to use if we
1:59:40
want we can also gate access based on IPS all kinds of settings you can mess with here so now that we've deployed the
1:59:46
database it's time to deploy the back end now to deploy the back end we first need to actually set up a git repository
1:59:53
because Coro will be able to view the git repository read it and actually automatically respond to new commits and
1:59:59
do automatic deployments and all kinds of cool stuff so we're going to go over to our code here and we're going to
Deployment Configuration
2:00:04
start setting this up to work for a git repository now to do that we're going to create a new file so we're going to make
2:00:10
a new file called G ignore okay inside of the G ignore we're going to ignore the environment variable
2:00:17
directory because or the environment uh what do you call it python virtual environment directory because we don't
2:00:22
need that we're then going to go to front end and we're going to go to our get ignore and we're just going to add
2:00:27
the EnV file because we don't want to include that in the git repo and we're going to go to backend and we're going
2:00:34
to make a git ignore and inside backend we're going to ignore the EnV and the
2:00:39
db. sqlite3 uh which we want to ignore as well okay now that we've done that we're
2:00:46
just going to make a few deployment related files inside of our backend directory and and then we'll upload this
2:00:52
to GitHub so we're going to start by doing a Coro folder now inside of Coro
2:00:58
we're going to make a new file and this is going to be endpoints do yaml now this is where
2:01:05
we're going to specify the endpoints that we want to deploy and then we want to expose from this specific component
2:01:11
which is the back end now Coro obviously will look inside of this do Coro folder to find this configuration so we're
2:01:19
going to write here the version which is 0. .1 we're then going to specify our end points now for the end points we're
2:01:26
going to specify a name the name can just be rest API doesn't really matter
2:01:31
what you call it and now we're going to specify a few other things so we're going to do the port the port is going
2:01:38
to be 8,000 the context is going to be a single forward slash the type is going
2:01:46
to be rest and the network visibility is
2:01:51
going to be public now this is a basic configuration that Coro is going to look
2:01:56
for when we're deploying a rest API the port obviously needs to match the port of our D Jango API which is 8,000 type
2:02:04
of course is going to be rest because this is a rest API when we set the network visibility to public that means
2:02:10
anyone will be able to view this we also could specify it as project or organization and then for the context
2:02:16
this is the base path of the API that we want to expose in this case I just want to expose the entire one so I'm going
2:02:23
with Slash okay and that's what you guys will use as well obviously there's a lot of details for this in the documentation
2:02:29
on the Coro website you guys can check that out if you want to learn more about how to set up these configurations especially for something a bit more
2:02:36
advanced now we also need to make one more file this will be the last one that we need to do and this is called the
2:02:42
proc file and the proc file is going to specify the command to start executing our application and that command is
2:02:48
going to be web colon and then python manage. pi and then run server and then
2:02:54
it's going to be 0.0.0.0 Port 8,000 okay so exactly what we would
2:03:00
normally do to execute our server except this time we're doing 0.0.0.0 which
2:03:05
means run on any origin or on the public IP address of the server that we're
2:03:11
executing on so this way it'll be public and anyone will be able to access it perfect so that's it for uh the kind of
2:03:18
configuration now what we need to do is add this to GitHub so we're going to make a new git repository with the
2:03:23
command get anit we're going to type G add Dot and then get commit hyphen M and
2:03:29
then first commit okay so we just make a commit we are then going to change the branch so
2:03:35
we're going to type git Branch hyphen M and then main this is
2:03:41
going to change the branch from Master to main which we need to do when we push to get we're going to clear this and
2:03:48
we're going to go over to get make a new remote repo and then add here and push this code to GitHub so I'm on GitHub
2:03:54
here and I've just made a new repo called Django react full stack app it's important that we make this public
2:04:00
because in the developer tier for Coro we can only have public repositories we're not going to add a read me we
2:04:06
already have the repository set up we just need to add the origin and then push our code so we're just going to
2:04:11
take this Command right here which is get remote add origin and we're going to move over here and paste this in our
2:04:18
terminal okay we're then going to push this so get push - origin and then Main and this will
2:04:25
push all of the code to the remote repo so we can then start setting up our deployment okay so let's go back here
2:04:31
and let's refresh we'll see here when we refresh we get all of our code popping up now what we can do is go back here to
2:04:39
Coro and we can go to the overview tab so now that all of this is set up on GitHub we're going to create a new
2:04:45
project in Coro now to do that you can go to the overview Tab and then click on create project or you can go up here
2:04:51
here and make a new project so I'm going to click on create project I'm going to call this D Jango react tutorial and I'm
2:04:58
going to use the mono repo because we just have one repo that contains all of our project code so we're going to go
Choreo Project Setup
2:05:04
next and we're going to authorize this with GitHub now you're going to have to go through a few steps here to authorize
2:05:09
it it's very straightforward just give it access to your repos then what you're going to need to do is go to the GitHub
2:05:15
repository and select the one you want so in my case it's Jango react full
2:05:20
stack app now here you can select the branch I've selected main cuz that's the only branch that I have but you could
2:05:26
set up a separate deployment branch and that would probably be a good idea so let's go next and notice that it's
2:05:31
actually automatically going to detect our different components now I want to show you how we manually create them so
2:05:37
I'm just going to click on create for now it's going to go ahead and make the new project and then we can add the
2:05:42
components ourself so let's go ahead and do that the first thing we're going to do is add a new service the service is
2:05:48
going to be for our rest API so I'm going to click on service here and for the component name I am going to
2:05:54
go with the back end and for the description we'll just leave it empty
2:05:59
and I'm going to select python as my build pack now for the python directory I'm going to select backend okay and for
2:06:06
the language version I'm going to go with 3.10 so let's go ahead and click create and notice there's a bunch of other
2:06:12
services you could make here okay so Coro is going to automatically go ahead and make this backend service for us and
2:06:19
while it does that I'm going to create the front-end service now for the front end service we're going to go with a web
2:06:24
application for the name this is going to be the front end and for the build pack this is going to be react now for
2:06:31
the project directory this is going to be the front end okay and for the build
2:06:36
command this is going to be npm install and npm run built we're then going to
2:06:44
have the build path as/ D this is where the output file will go
2:06:50
when we actually build this application then for the node version we're going to go with 20.0 you can go
2:06:56
with any version you want really I think as long as it's high enough but 20.0 should be fine okay so that should be
2:07:02
good that's going to create the front end component for us and now what we'll need to do is build each of these
2:07:09
components and then deploy them now there's a few other steps as well obviously but this is pretty straightforward and it's actually pretty
2:07:16
impressive how fast we can get this deployed out okay so let's go back to our back end we can do that by just
2:07:23
selecting the service up here and from our back end we're going to go to the build tab now you'll notice that there's
2:07:29
a bunch of other tabs here right like usage insights observability devops testing the API deploying managing right
2:07:36
it's got everything you can imagine now what we can do is build latest or we can view the different commits and we can
Backend Deployment
2:07:41
build a specific commit in our case we just want to build latest so we're going to click on build latest we're going to
2:07:47
wait for a little bit it should build the latest version of this and then we can go ahead and deploy it and we can
2:07:52
test the API all right so the build has just completed and now what we'll do is go over to deployment now from
2:07:59
deployment we can deploy the build you also will have noticed from the build tab we have the option to Auto deploy if
2:08:04
we enable that as soon as a build is finished or actually as soon as a new commit is made on our Branch it will
2:08:10
automatically build it and then deploy it now you can see that what we can do here is configure and deploy so if I
2:08:17
click on this it gives me the option to actually Mount some environment variables now that's what I'll do now
2:08:22
because remember we need to pass the environment variables for our database configuration so what we can do is add a
2:08:29
bunch of environment variables in this case it's just allowing us to do one so I'm actually going to do it another way I'm just going to click on next we have
2:08:35
the option to file Mount uh endpoint details here this is fine we can go ahead and deploy that and once this
2:08:42
first version is deployed it's going to give us the option to configure some secrets so I'm going to click on manage config in secrets and here I'm going to
2:08:50
click on Create and then I'm going to going to go secret and environment variable now the reason this is secret is because I don't want anyone to be
2:08:55
able to view this once it's been created this is going to be the data to connect to my database now what we'll do here is
2:09:02
just add the different environment variables that we need that match what we had in our local repo I'm going to
2:09:07
call this EnV and then what I'm going to do is go back to my code here I'm going
2:09:12
to go find my environment variable file which is this and I'm going to copy all of these values over so let me do that
2:09:18
and I'll be right back all right so I've added all of these values and notice that I'm not used quotation marks for
2:09:24
any of them I'm just adding them as plain text inside of here I have my host Port user name and password the exact
2:09:30
same as I had from the environment variable file in my local repository what I'm going to do now is press on
2:09:36
create this is going to add the environment variables as Secrets now if you want to edit them you'll have to
2:09:42
actually read all of the values because you can't view the contents anymore we'll go back to deploy and within
2:09:48
deploy now it should automatically redeploy with those environment variables so now what will happen is our
2:09:54
API will be deployed if we want to view the end points we can view them right here we can see the project URL and the
2:10:00
public URL however the public URL is automatically going to be protected from
2:10:05
coreo now the way that this works is that Coro is automatically going to add an API key that we need to pass in order
2:10:13
to access this URL so if I just try to go to the URL in fact I can do that just to show you you'll notice that it's not
2:10:20
going to work so if I go to the public URL and I paste it in here it's just going to tell me hey like you don't have
2:10:25
the correct security credentials to be able to view this now that's intentional because Coro will automatically protect
2:10:31
your apis for you and if you want to disable the protection which is what we're going to do you need to do that
2:10:37
manually so what we're going to go to now is the settings page within manage
2:10:42
sorry for the quick cut here but I do need to quickly jump in because the website has changed a little bit since I
2:10:47
filmed this video so I just want to show you quickly how to get to the correct page page so that none of you are lost
2:10:53
so in the video what you're going to see me do is go to this manage Tab and then for manage go to settings now that's no
2:10:58
longer available and instead what you're going to need to do is go to the deploy Tab and then simply click on endpoint
2:11:05
configurations from this point forward all of the settings and all of the instructions I give you are the same
2:11:11
simply do them from this page rather than the page you're seeing in this video now from here what we're going to
2:11:17
do is change the API visibility to be public now we want this to be public so
2:11:22
that anyone can access this API and use it to interact with our application now as well as that we're going to go and
2:11:29
press on edit now from edit we're going to change some of the settings here by disabling the application Level security
2:11:36
Now this tells you exactly what it does this option determines the type of security that will be used to secure the API an API can be secured with either
2:11:42
ooth or any other available security type or it can be secured with both of them if oo 2 option is selected relevant
2:11:47
API will require a valid oo 2 token for successful in if so we want to disable
2:11:53
that because we already have our JWT tokens and for this example it's going to be a little bit complex to have this
2:11:58
enabled so what we'll do is disable this and press on Save when we do that what's
2:12:04
going to happen now is that when we try to access the API we will actually be able to send a request to it whereas
2:12:10
before we would need to pass an API token and that would add kind of some more code changes which I don't want to
2:12:16
make at this point because we've already done quite a few changes so now that we've changed our settings what we're going to do is go back to the deploy Tab
2:12:24
and if you haven't already just redeploy the API to make sure the new settings are applied now we can go view the
2:12:30
endpoints and if we take the public URL and we paste it in here we can see if this is working or not or if we get any
2:12:36
issues now in this case it just says bad request which is fine because it means we were actually able to access the API
2:12:42
but what happened was we didn't have a security um what do you call it issue like we had before right so here we just
2:12:48
access a route that didn't exist but if I go to something like / API SL token we can see if that one's going to load and
2:12:55
in this case it gave us some connection error which tells me there's probably some issue with the database connection
2:13:00
so let's actually go check that quickly the way we can do that is we can go to observability and we can go to metrics
2:13:07
and we can actually see all of the logs for what's happening with our application so let's go here give it a
2:13:13
second to load and see what we're getting we can also see the throughput the latency and some other issues or not
2:13:19
other issues other stats I guess which are meaningful okay so when we go here it just says
2:13:24
that we're not able to connect to the database so what most likely happened is the database just turned off because it's been an hour so let me return the
2:13:30
database back on and in fact I'll show you how we do that so what I can do is get out of this project go to
2:13:36
dependencies databases and we'll see if that was the culprit and it was you can see the database is powered off so what
2:13:43
I'm going to do is just power on this service it's going to take a second to power back on and we'll go back into our
2:13:49
application so Jango re act tutorial we'll just give it a minute to power back on we'll go into our components
2:13:56
we'll go into our backend and we'll just redeploy this as soon as the database is powered back on and we should be good to
2:14:03
go and uh actually able to well interact with the application and the API all right so the database is powered back on
2:14:09
so let's just redeploy our app here to make sure that everything is all good we'll wait for that to finish and then
2:14:16
what we can do is go to the endpoint and we can test this again just to see if everything is functioning now assuming
2:14:22
the back end is working then the next step is to deploy the front end once we have the front end deployed we just need
2:14:27
to connect it to the back end and once the two are connected we'll have a fully deployed application and you'll actually
Frontend Deployment
2:14:33
have a project that you can submit to the Coro wso2 challenge to potentially win the cybertruck don't forget about
2:14:40
that so now our back end has been successfully deployed and it's time to move on to the front end so what we're
2:14:46
going to do is make a new component we're going to go to the front end component I should say and from the front front end now we're going to go to
2:14:52
build we're going to build the latest version of our front end and once this is built we're going to check out the
2:14:58
front end then we're going to connect it to the back end so the front end has been built we could enable auto deploy
2:15:04
if we want but I'm just going to go over to deploy and now we will deploy this now there's a few settings that we need
2:15:10
to change first of all so we're going to go to authentication settings and we're going to disable the managed authentication with Coro as I talked
2:15:17
about before we're not using the authentication for this specific app however if you were building this from
2:15:23
the ground up and you wanted to use the authentication from Coro obviously you would enable this and they have some really good documentation that shows you
2:15:30
how to handle off using the Coro platform they can do user authentication they can do application Level
2:15:35
authentication it's very interesting so I definitely recommend checking it out but just for this app since the whole
2:15:40
point was to look at JWT tokens in Django we don't need this feature so I'm going to click on deploy and now that
2:15:47
we've disabled that it's going to deploy this it's going to take a second and once this has been deployed we
2:15:53
should see the front end working so let's click on this web app URL uh and we're getting a not found error okay so
2:16:01
let's give it a second here because it probably just needs a minute to spin up let's go to it again and not found okay
2:16:07
let me look at the issue here and I will be right back all right so I just had to deploy the app and wait a second and
2:16:13
there we go we now see that we have our front end and this is deployed we can go
2:16:18
to register if we try to go to something that doesn't exist we'll get that not found page we can go back to register
Connecting The Fronted To The Backend
2:16:27
here but you'll notice that if I try to actually use this to make a new account it's not going to work now and the
2:16:32
reason it doesn't work is because we're not connected to the back end so let's now go with the connection and then that we'll wrap up this video so in order to
2:16:39
make the connection here what we need to do is go to dependencies and then connections now what Coro can do which
2:16:46
is really interesting is actually deploy our backend on the same origin as our front end or at least allow us to make
2:16:53
the request on the same origin so that we don't need to be interacting with something that's outside of this origin
2:17:00
which is actually quite useful for a lot of applications so you're going to see that I clicked on create there and what
2:17:05
I'm going to do is use my backend rest API so I'm going to go backend rest API here going to select that we'll just
2:17:11
call this backend as the connection name and click on create now that we've done
2:17:16
this you're going to see a bunch of instructions on the right hand side for how to do this action now this is if you
2:17:22
were using the authentication handled by coreo in our case we are not so we don't need to follow the steps on the right
2:17:28
hand side but if you are again check out these steps the authentication is a very useful feature especially if you don't
2:17:34
build it in yourself like we have with Jango so what we're going to do here is copy this service URL now this service
2:17:41
URL is hosted on the same domain as our front end which means we can send requests to this and then whatever we
2:17:48
add afterwards is the API route that will be be redirected to so the way that
2:17:53
we're going to do this is we're going to go back to our repository here I'm just going to close all of this and I'm going
2:17:59
to go to my front end directory and to api.js now all I'm going to do is I'm going to say const API URL is equal to
2:18:08
and I'm going to paste this root in here now notice I'm not putting a different domain I'm just putting the path that
2:18:14
will Bey on the same domain now what I'm going to do is I'm going to look for the presence of this environment variable
2:18:20
file if it exists I'm going to use what's inside of there otherwise I'm going to use the API URL now let me just
2:18:27
format this so it's a bit easier to read so what this will do now is it will use
2:18:32
this when we're in the deployed environment which is the connection that we need to our backend so what we can do
2:18:38
now is we can make a new commit so we can say get add Dot and then get commit
2:18:45
hyphen M add backend URL and then we can type get push origin Main and we can
2:18:53
make a push now what we'll need to do is just redeploy the front end with this new commit and what will happen is now
2:18:59
the front end will make a request to its same origin with this slash URL as the
2:19:04
base URL and then it will add the API path afterwards so we'll go to like API
2:19:10
SL token or register or whatever the URLs are so that's it that's really all
2:19:15
we have to do for the connection it's quite easy I'm pretty impressed with how Coro has been able to handle this and
2:19:21
what we can do is go back to build now and we can go to build latest so let's view the commits first of all okay we
2:19:27
have the backend URL so let's go with build latest and build that out okay so
2:19:34
our front end is now built so let's go back to deploy and let's deploy the new version
2:19:40
here okay so that's going to take a second to deploy and once that's finished everything should be good to go
2:19:46
fingers crossed obviously things can go wrong but if that's the case we could go and we could check out the logs we can
2:19:51
use all of the tools that Coro has built into the platform now let's go to the web
2:19:57
URL okay there we go we have V plus react let's go to SL register and make a
2:20:02
new account okay so we got to spell register correctly though okay so let's go with
2:20:09
new user and then we'll go with a password
2:20:15
here okay good sign that's taking a second to load that means it's probably connected to the remote database okay so
2:20:22
that account was created so now let's try to log into this okay and then we
2:20:28
should be able to view our notes okay so stop telling me to change my password I know it's very weak that's fine so let's
2:20:34
make a new note say new note test content let's submit that should take a
2:20:41
second here the note should be added then we'll be able to view them delete them Etc now I know there's a little bit
2:20:46
of latency it's just because of the database that we're using so it takes a second to make all all of those operations uh but if you're using one
2:20:53
that was actually deployed that wasn't kind of the trial or like the temporary test database obviously this would be a
2:20:59
lot faster all right so the new note has been added here and we can see that all of the functionality is working properly
2:21:06
I guess the last thing we can do is log out and when we do that brings us back to the login page and then we can log in
2:21:12
with another account so there you go we now have a fully deployed application completely for free by the way that you
2:21:18
could now use to enter this cyber truck giveaway so with that said guys I'm going to wrap up the video here all of
2:21:24
this code will be available on GitHub so you can simply download it from the link in the description you can modify it
2:21:30
tweak it whatever you need to do a big thank you to Coro for sponsoring this video and for hosting that giveaway make
2:21:35
sure you check out the platform more and you enter that giveaway again you have a chance to win a cyber truck or
2:21:41
$100,000 and then there's going to be 10 other people that are picked to win a MacBook Pro 14in with a M3 chip wrap it
2:21:49
up here guys I hope you enjoyed enjy if you did leave a like subscribe to the channel and I will see you in the next
2:21:55
[Music]
2:22:01
one





TRAVERSY INSTRUCTIONS BELOW ...
V V V

"""
NOTE: This tutorial is based on the tutorials at:
https://www.valentinog.com/blog/drf/#Django_REST_with_React_Django_and_React_together
and
https://v1k45.com/blog/modern-django-part-1-setting-up-django-and-react/

IMPLEMENT REACT INTO DJANGO PROJECT:
1. We will do this manually, not use "create react app" or anything like that, because we're integrating react into Django
2. We create a "frontend django app" (i.e., a "subfolder" inside the react project folder; e.g., goalsdrfrontend)
3. Inside there is where all of the react files will live as a template as an entry point for react
4. We'll have index.js as an entry point into javascript, then that will point to a main app component (App.js?) that will get loaded
5. We also need to install webpack, babel, etc.

SO, WITHOUT FURTHER ADO ...
1. cd into the same folder as manage.py (e.g., goalsdrbackend)
2. python manage.py startapp [goalsdrfrontend] (we get a new [goalsdrfrontend] folder and all the standard files that come with a django app)
3. (Next create a couple of directories that the react app can live in:)
4. mkdir -p ./goalsdrfrontend/src/components
5. mkdir -p ./goalsdrfrontend/{static,templates}/frontend # creating two folders/directories; on windows, do these separately
6. The src is where everything in our react application goes, including components and redux
7. "templates" handles the index.html file that gets loaded, basically our single page application
8. "static" is the compiled javascript, so web pack takes our react application (index.js is entry point), looks at that and compiles to a file main.js inside static
9. when you type npm run build (or npm run dev), it creates a static folder with all static assets and that lives here ^^

INSTALL WEBPACK, BABEL, ETC.:
1. cd (if needed) to be in the root (goalsdrbackend)
2. npm init -y # creates a package.json file with all of your javascript dependencies (-y keeps from asking questions)
3. npm i -D webpack webpack-cli # npm i -D means install as a devDependencies (in package.json file)
4. Note that, in the package.json file, webpack is added as a devDependencies
5. Off camera, Traversy initialized a Git repository with git init, then created a gitignore file with node modules, then went to gitignore.io and typed in "django" and it gave him defaults for gitignore.django, then did a simple commit
6. Now, install babel which will take care of transpiling javascript to newer features, as well as the react preset:
7. npm i -D @babel/core babel-loader @babel/preset-env @babel/preset-react babel-plugin-transform-class-properties
8. ^^ this is the babel core package, loader, and transform class properties, handles static class properties for ES
a. NOTE: babel-plugin-transform-class-properties was deprecated ...
b. so remove it from the package.json file and run npm install --save-dev @babel/plugin-proposal-class-properties!
c. (or just don't install babel-plugin-transform-class-properties in the first place!)

INSTALL REACT AND REACT DOM
1. npm i react react-dom prop-types
2. check package.json to make sure it matches Traversy
3. create a file in the root directory called .babelrc
4. it's a json object, so add the following:
{
    "presets": ["@babel/preset-env", "@babel/preset-react"],
}
5. create webpack config files: create a new file in the root called webpack.config.js
6. when you use webpack you have this webpack.config.js file, it can be confusing, but it's just loading the babel loader and includes:
module.exports = { // takes care of using babel loader to transpile our code
    module: {
        rules: [
            {
                test: /\.js$/, // regular expression saying: for any javascript file
                exclude: /node_modules/, // then we want to exclude anything that's in the node modules folder
                use: {
                    loader: "babel-loader",
                    /*
                    options: {
                        presets: ['@babel/env'],
                        plugins: ['@babel/plugin-proposal-class-properties']
                    
                    }
                    */
                }
            }
        ]
    }
}7. Inside package.json, we want to have a couple of scripts, because we need to compile our react application that lives in the frontend app
8. So in package.json, replace the "test" script with "dev"
9. In the same line, replace "echo" language with webpack ("dev": "webpack")
10. Add a flag so that mode is development ("dev": "webpack --mode development")
11. Look at the entry point for react, which is going to be the index.js file in the src folder, and then output it to the static folder
12. So ./goalsdrbackend/goalsdrfrontend/src/index.js
13. Then output, so --output ./goalsdrfrontend/static/frontend/main.js # the actual compiled javascript included in index.html template
14. So entire line is: "webpack --mode development --watch ./goalsdrfrontend/src/index.js --output-path ./goalsdrfrontend/static/frontend/",
a. NOTE: The "--watch" allows us to make and see changes without having to do npm run dev
15. Then after the comma, we'll have a build command as well:
16. "build": "webpack --mode production ./goalsdrfrontend/src/index.js --output-path ./goalsdrfrontend/static/frontend/"
17. so npm run dev runs development, and npm run build runs production

CREATE THE FILES FOR THE REACT APP
1. Now create index.js and main app component for react
2. Go into goalsdrfrontent/src and create a file called index.js
3. Load the main app component: import App from './components/App';
4. In src/components, create a new file called App.js # see comments in file
5. Create the index.html file where the <div> with the id of 'app' resides:
5. In templates/frontend, create a file called index.html (NOTE: '!', then enter (i.e., shift 1) will generate an HTML template)
6. See example HTML file for more detail: in the body, all that needed is an id of app (NOTE: '#app' and enter will auto-generate this)
7. include link and script files for connecting to bootstrap (see exmaple index.html file in project)

UPDATE DJANGO PROJECT
1. In settings.py file, unders INSTALLED_APPS, make sure to add 'goalsdrfrontend'
2. In goalsfrontend/views.py, this is where we need to point to frontend/index.html (see index method in goalsdrfrontend/views.py)
3. In goalsdrfrontend, create urls.py and add urls pattern for index method in goalsdrfrontend/views.py
4. THEN update goalsdrBACKend/urls.py to add path('', include('goalsdrfrontend.urls')) ABOVE the one added previously

INSTALL CDN FOR BOOTSTRAP (?)
1. Go to bootswatch.com, click on the download arrow, right click on the min.css option to open in new tab, copy the url
2. Paste the copied URL into a link tab in the <head> (e.g.,  <link rel="stylesheet" href="https://bootswatch.com/5/cosmo/bootstrap.min.css">)
3. Go to getbootstrap.com, find the get started/CDN section, copy all necessary <script> tags and paste them into index.html

CREATE NEW COMPONENTS
1. Inside src/components folder, create a folder called layout; for each component created there will be specific folders for
2. Inside layout create header.js (install ES7 React/Redux/Graph ... extensiona. then type rcf [tab] to create a template)
3. Go to getbootstrap.com, and search navbar; find a navbar you like and copy and paste the code into the return statement in Header.js
a. NOTE: React's "HTML" language, JSX does not like the word "class", so ...
b. Highlight one "class" and select each additional word "class" using CTRL-D, then replace with "className"
4. Create a new folder under src/components named "tags"
5. Create 3 files: 1. Dashboard.js (which holds the other two); 2. Form.js (the form to add a tag); and 3. Tags.js (a list of tags)
"""